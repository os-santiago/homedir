name: Deploy to VPS (Podman)

on:
  workflow_call:

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      DATA_DIR: ${{ vars.DATA_DIR || '/opt/homedir/data' }}
      FALLBACK_IMAGE_REF: ${{ vars.IMAGE_REF }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Try to load image ref from build artifact
        id: artifact-ref
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: pr-image-ref
          path: /tmp/image-ref

      - name: Read image ref from artifact (if present)
        id: read-artifact
        if: steps.artifact-ref.outcome == 'success'
        run: |
          set -euo pipefail
          FILE=/tmp/image-ref/image-ref.txt
          if [ -f "$FILE" ]; then
            REF_LINE=$(cat "$FILE")
            REF_VALUE=${REF_LINE#REF=}
            if [ -n "$REF_VALUE" ]; then
              echo "Using REF from artifact: $REF_VALUE"
              echo "IMAGE_REF=$REF_VALUE" >> $GITHUB_ENV
              exit 0
            fi
          fi
          echo "No REF found in artifact; expecting IMAGE_REF var instead."

      - name: Prepare SSH key
        env:
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
        run: |
          if [ -z "${VPS_SSH_KEY:-}" ]; then
            echo "VPS_SSH_KEY secret is required"; exit 1; fi
          install -m 700 -d ~/.ssh
          echo "${VPS_SSH_KEY}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Deploy via Podman on VPS
        env:
          VPS_HOST: ${{ vars.VPS_HOST }}
          VPS_USER: ${{ vars.VPS_USER }}
          VPS_PORT: ${{ vars.VPS_PORT || '22' }}
          APP_PORT: ${{ vars.APP_PORT || '8080' }}
          REGISTRY: ${{ vars.REGISTRY || 'quay.io/sergio_canales_e' }}
          IMAGE_NAME: ${{ vars.IMAGE_NAME || 'homedir' }}
          OIDC_CLIENT_ID: ${{ secrets.OIDC_CLIENT_ID }}
          OIDC_CLIENT_SECRET: ${{ secrets.OIDC_CLIENT_SECRET }}
          SESSION_KEY: ${{ secrets.SESSION_KEY }}
          NOTIFICATIONS_USER_HASH_SALT: ${{ secrets.NOTIFICATIONS_USER_HASH_SALT }}
        run: |
          if [ -z "${VPS_HOST}" ] || [ -z "${VPS_USER}" ]; then
            echo "VPS_HOST and VPS_USER must be set as repository variables"; exit 1; fi
          IMAGE="${IMAGE_REF:-${REF:-${FALLBACK_IMAGE_REF:-}}}"
          IMAGE="${IMAGE#docker://}"
          IMAGE="${IMAGE#docker:}"
          if [ -z "$IMAGE" ]; then
            echo "IMAGE_REF must be provided via artifact or vars" >&2
            exit 1
          fi
          echo "Using image: ${IMAGE}"
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no -p "${VPS_PORT:-22}" "${VPS_USER}@${VPS_HOST}" <<EOF
          set -euo pipefail
          IMAGE="${IMAGE}"
          CONTAINER_NAME="${IMAGE_NAME:-homedir}"
          APP_PORT="${APP_PORT:-8080}"
          DATA_DIR="${DATA_DIR:-/opt/homedir/data}"
          mkdir -p "${DATA_DIR}"
          chown -R 1001:1001 "${DATA_DIR}" || true
          podman pull "$IMAGE"
          # Stop any container currently bound to the target port to avoid EADDRINUSE
          for c in $(podman ps -a --format '{{.Names}} {{.Ports}}' | awk "/${APP_PORT:-8080}/ {print \$1}"); do
            podman stop "$c" || true
            podman rm "$c" || true
          done
          # Kill any other process still holding the port (defensive)
          if command -v fuser >/dev/null 2>&1; then
            fuser -k "${APP_PORT}/tcp" || true
          fi
          if podman ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}\$"; then
            podman stop "${CONTAINER_NAME}" || true
            podman rm "${CONTAINER_NAME}" || true
          fi
          podman run -d --name "${CONTAINER_NAME}" --restart=always \
            -p "\${APP_PORT}:8080" \
            -e eventflow.data.dir=/work/data \
            -e OIDC_CLIENT_ID="${OIDC_CLIENT_ID}" \
            -e OIDC_CLIENT_SECRET="${OIDC_CLIENT_SECRET}" \
            -e SESSION_KEY="${SESSION_KEY}" \
            -e NOTIFICATIONS_USER_HASH_SALT="${NOTIFICATIONS_USER_HASH_SALT}" \
            -v "\${DATA_DIR}:/work/data:Z" \
            "$IMAGE"
          EOF

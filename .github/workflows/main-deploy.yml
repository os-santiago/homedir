# Deploy workflow for main branch. Promotes the image built in PR CI and
# deploys it to GKE using the same digest that was scanned and signed.
name: Main Deploy (Promote & GKE)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: main-deploy-${{ github.sha }}
  cancel-in-progress: true

env:
  REGISTRY:   ${{ vars.REGISTRY }}
  IMAGE_NAME: ${{ vars.IMAGE_NAME }}
  GKE_PROJECT:   ${{ vars.GKE_PROJECT }}
  GKE_CLUSTER:   ${{ vars.GKE_CLUSTER }}
  GKE_LOCATION:  ${{ vars.GKE_LOCATION }}
  GKE_NAMESPACE: ${{ vars.GKE_NAMESPACE || 'prod' }}
  GH_TOKEN: ${{ github.token }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Read version from pom.xml
        id: ver
        working-directory: quarkus-app
        run: |
          V=$(./mvnw -q -Dexec.executable='echo' -Dexec.args='${project.version}' --non-recursive exec:exec)
          echo "v=$V" >> $GITHUB_OUTPUT

      - name: Login to Quay
        run: echo "${{ secrets.QUAY_PASSWORD }}" | docker login "${REGISTRY}" -u "${{ secrets.QUAY_USERNAME }}" --password-stdin

      - name: Resolve digest (same PR image) without apt-get
        id: ref
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          prs=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls -H "Accept: application/vnd.github+json")
          pr=$(echo "$prs"   | jq -r '.[0].number')
          head=$(echo "$prs" | jq -r '.[0].head.sha')
          DIGEST=$(docker buildx imagetools inspect "${REGISTRY}/${IMAGE_NAME}:pr-${pr}-${head}" --format '{{json .Manifest.Digest}}' | tr -d '"')
          if [ -z "$DIGEST" ]; then
            echo "Failed to resolve image digest" >&2
            exit 1
          fi
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "ref=${REGISTRY}/${IMAGE_NAME}@${DIGEST}" >> $GITHUB_OUTPUT
          echo "REF=${REGISTRY}/${IMAGE_NAME}@${DIGEST}" >> $GITHUB_ENV

      - name: Promote digest to semver tags (aliases)
        if: steps.ref.outcome == 'success'
        run: |
          set -euo pipefail
          REF="${{ steps.ref.outputs.ref }}"
          V="${{ steps.ver.outputs.v }}"
          if [ -z "$REF" ]; then
            echo "Missing image reference" >&2
            exit 1
          fi
          MAJOR=${V%%.*}
          MINOR=${V%.*}
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:v$V $REF
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:$V $REF
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:$MINOR $REF
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:$MAJOR $REF

      - name: (Optional) Tag for traceability
        if: steps.ref.outcome == 'success'
        run: |
          SHORT=$(echo "${{ github.sha }}" | cut -c1-12)
          skopeo copy docker://$REF docker://${REGISTRY}/${IMAGE_NAME}:main-${SHORT}

      # ---- GKE Auth & Deploy (usa tus secretos de GCP) ----
      - name: Auth to GCP
        if: steps.ref.outcome == 'success'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Get GKE credentials
        if: steps.ref.outcome == 'success'
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location:     ${{ env.GKE_LOCATION }}
          project_id:   ${{ env.GKE_PROJECT }}

      - name: Update OAuth secret
        if: steps.ref.outcome == 'success'
        env:
          OIDC_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          OIDC_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          OIDC_AUTH_SERVER_URL: ${{ secrets.OIDC_AUTH_SERVER_URL }}
          OIDC_AUTH_URI: ${{ secrets.OIDC_AUTH_URI }}
          OIDC_TOKEN_URI: ${{ secrets.OIDC_TOKEN_URI }}
          OIDC_JWKS_URI: ${{ secrets.OIDC_JWKS_URI }}
          OIDC_REDIRECT_URI: ${{ secrets.OIDC_REDIRECT_URI }}
        run: |
          kubectl -n "$GKE_NAMESPACE" create secret generic google-oauth \
            --from-literal=client-id="$OIDC_CLIENT_ID" \
            --from-literal=client-secret="$OIDC_CLIENT_SECRET" \
            --from-literal=auth-server-url="$OIDC_AUTH_SERVER_URL" \
            --from-literal=auth-uri="$OIDC_AUTH_URI" \
            --from-literal=token-uri="$OIDC_TOKEN_URI" \
            --from-literal=jwks-uri="$OIDC_JWKS_URI" \
            --from-literal=redirect-uri="$OIDC_REDIRECT_URI" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply manifests & rollout (by version tag)
        if: steps.ref.outcome == 'success'
        run: |
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/namespace.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/managed-cert.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/service.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/deployment.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/ingress.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/pvc.yaml

          IMG="${REGISTRY}/${IMAGE_NAME}:${{ steps.ver.outputs.v }}"
          echo "Rolling out $IMG"
          kubectl -n "$GKE_NAMESPACE" set image deployment/eventflow eventflow=$IMG
          kubectl -n "$GKE_NAMESPACE" rollout status deployment/eventflow

# Deploy workflow for main branch. Promotes the image built in PR CI and
# deploys it to GKE using the same digest that was scanned and signed.
name: Main Deploy (Promote & GKE)

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  id-token: write

concurrency:
  group: main-deploy-${{ github.sha }}
  cancel-in-progress: true

env:
  REGISTRY:   ${{ vars.REGISTRY }}
  IMAGE_NAME: ${{ vars.IMAGE_NAME }}
  GH_TOKEN: ${{ github.token }}
  PROJECT_ID: scanales-191111
  SERVICE_ACCOUNT_NAME: github-actions-deployer
  GKE_CLUSTER_NAME: eventflow-cluster
  GKE_ZONE: us-central1
  GKE_NAMESPACE: eventflow

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Read version from pom.xml
        id: ver
        working-directory: quarkus-app
        run: |
          V=$(./mvnw -q -Dexec.executable='echo' -Dexec.args='${project.version}' --non-recursive exec:exec)
          echo "v=$V" >> $GITHUB_OUTPUT

      - name: Login to Quay
        run: echo "${{ secrets.QUAY_PASSWORD }}" | docker login "${REGISTRY}" -u "${{ secrets.QUAY_USERNAME }}" --password-stdin

      - name: Resolve digest (same PR image) without apt-get
        id: ref
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          prs=$(gh api repos/${{ github.repository }}/commits/${{ github.sha }}/pulls -H "Accept: application/vnd.github+json")
          pr=$(echo "$prs"   | jq -r '.[0].number // empty')
          head=$(echo "$prs" | jq -r '.[0].head.sha // empty')

          if [ -z "$pr" ] || [ -z "$head" ]; then
            # Fallback for squash merges: parse PR number from commit message
            pr=$(git show -s --format=%s HEAD | sed -n 's/.*(#\([0-9]\+\)).*/\1/p')
            if [ -n "$pr" ]; then
              pr_json=$(gh api repos/${{ github.repository }}/pulls/$pr -H "Accept: application/vnd.github+json")
              head=$(echo "$pr_json" | jq -r '.head.sha // empty')
            fi
          fi

          if [ -z "$pr" ] || [ -z "$head" ]; then
            echo "Failed to determine PR information" >&2
            exit 1
          fi

          DIGEST=$(docker buildx imagetools inspect "${REGISTRY}/${IMAGE_NAME}:pr-${pr}-${head}" --format '{{json .Manifest.Digest}}' | tr -d '"')
          if [ -z "$DIGEST" ]; then
            echo "Failed to resolve image digest" >&2
            exit 1
          fi
          echo "digest=$DIGEST" >> $GITHUB_OUTPUT
          echo "ref=${REGISTRY}/${IMAGE_NAME}@${DIGEST}" >> $GITHUB_OUTPUT
          echo "REF=${REGISTRY}/${IMAGE_NAME}@${DIGEST}" >> $GITHUB_ENV

      - name: Promote digest to semver tags (aliases)
        if: steps.ref.outcome == 'success'
        run: |
          set -euo pipefail
          REF="${{ steps.ref.outputs.ref }}"
          V="${{ steps.ver.outputs.v }}"
          if [ -z "$REF" ]; then
            echo "Missing image reference" >&2
            exit 1
          fi
          MAJOR=${V%%.*}
          MINOR=${V%.*}
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:v$V $REF
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:$V $REF
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:$MINOR $REF
          docker buildx imagetools create -t ${REGISTRY}/${IMAGE_NAME}:$MAJOR $REF

      - name: (Optional) Tag for traceability
        if: steps.ref.outcome == 'success'
        run: |
          SHORT=$(echo "${{ github.sha }}" | cut -c1-12)
          skopeo copy docker://$REF docker://${REGISTRY}/${IMAGE_NAME}:main-${SHORT}

      - name: Write GCP credentials
        env:
          GCP_SERVICE_ACCOUNT_KEY_JSON: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY_JSON }}
        run: echo "$GCP_SERVICE_ACCOUNT_KEY_JSON" | base64 -d > "$HOME/key.json"

      - name: Authenticate to Google Cloud
        run: |
          gcloud auth activate-service-account --key-file="$HOME/key.json"
          gcloud config set project "$PROJECT_ID"
          gcloud config set compute/zone "$GKE_ZONE"

      - name: Configure kubectl
        run: |
          gcloud container clusters get-credentials "$GKE_CLUSTER_NAME" --zone "$GKE_ZONE" --project "$PROJECT_ID"

      - name: Update OAuth secret
        if: steps.ref.outcome == 'success'
        env:
          OIDC_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          OIDC_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          OIDC_AUTH_SERVER_URL: ${{ secrets.OIDC_AUTH_SERVER_URL }}
          OIDC_AUTH_URI: ${{ secrets.OIDC_AUTH_URI }}
          OIDC_TOKEN_URI: ${{ secrets.OIDC_TOKEN_URI }}
          OIDC_JWKS_URI: ${{ secrets.OIDC_JWKS_URI }}
          OIDC_REDIRECT_URI: ${{ secrets.OIDC_REDIRECT_URI }}
        run: |
          kubectl -n "$GKE_NAMESPACE" create secret generic google-oauth \
            --from-literal=client-id="$OIDC_CLIENT_ID" \
            --from-literal=client-secret="$OIDC_CLIENT_SECRET" \
            --from-literal=auth-server-url="$OIDC_AUTH_SERVER_URL" \
            --from-literal=auth-uri="$OIDC_AUTH_URI" \
            --from-literal=token-uri="$OIDC_TOKEN_URI" \
            --from-literal=jwks-uri="$OIDC_JWKS_URI" \
            --from-literal=redirect-uri="$OIDC_REDIRECT_URI" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply manifests & rollout (by version tag)
        if: steps.ref.outcome == 'success'
        run: |
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/namespace.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/managed-cert.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/service.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/deployment.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/ingress.yaml
          kubectl apply -n "$GKE_NAMESPACE" -f deployment/pvc.yaml

          IMG="${REGISTRY}/${IMAGE_NAME}:${{ steps.ver.outputs.v }}"
          echo "Rolling out $IMG"
          kubectl -n "$GKE_NAMESPACE" set image deployment/eventflow eventflow=$IMG
          kubectl -n "$GKE_NAMESPACE" rollout status deployment/eventflow
